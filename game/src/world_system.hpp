#pragma once

// internal
#include "common.hpp"

// stlib
#include <vector>
#include <random>

#define SDL_MAIN_HANDLED
#include <SDL.h>
#include <SDL_mixer.h>

#include "render_system.hpp"

#include "reloadability.hpp"
 
void createFloorGoals(); 
void resetGoalManagerStats();

// Container for all our entities and game logic.
// Individual rendering / updates are deferred to the update() methods.
class WorldSystem
{
public:
	WorldSystem();

	// creates main window
	GLFWwindow* create_window();

	// starts and loads music and sound effects
	bool start_and_load_sounds();

	// call to close the window
	void close_window();

	// starts the game
	void init(RenderSystem* renderer);

	// releases all associated resources
	~WorldSystem();

	// steps the game ahead by ms milliseconds
	bool step(float elapsed_ms);

	// check for collisions generated by the physics system
	void handle_collisions();

	// should the game be over ?
	bool is_over() const;

	// change the level
	void transitionToScene(GAME_SCREEN_ID game_screen_id, float fade_to_black_duration, float fade_from_black_duration);
	bool is_transitioning = false;
	void loadLevel();

	void pause_on(std::string state);
	void pause_off();

	// is the player dead?
	bool player_dead;
	bool is_player_input_enabled;
	bool audio_slider_is_held = false;

	void reset_player_spells();

	GAME_SCREEN_ID get_game_screen() { return game_screen; }

	void update_key_held_map();
	void update_volume();

	Setting setting = Setting();

private:

	// A map to keep track of whether a key is currently being held
	std::unordered_map<unsigned int, bool> key_held_map = {
		{ GLFW_KEY_W, false },
		{ GLFW_KEY_A, false },
		{ GLFW_KEY_S, false },
		{ GLFW_KEY_D, false },
	};

	

	// input callback functions
	void on_key(int key, int, int action, int mod);
	void on_mouse_move(vec2 pos);
	void on_mouse_button_pressed(int button, int action, int mods);

	// restart level
	void restart_game();

	// OpenGL window handle
	GLFWwindow* window;

	std::vector<Entity> to_be_destroyed;
	std::vector<Entity> already_collided;

	void handle_projectile_enemy_collision(Entity projectile_entity, Entity enemy_entity);
	void handle_projectile_chest_collision(Entity projectile_entity, Entity chest_entity);
	void handle_projectile_player_collision(Entity projectile_entity, Entity player_entity);
	void handle_projectile_wall_collision(Entity projectile_entity, Entity wall_entity);
	void handle_wall_enemy_collision(Entity projectile_entity, Entity enemy_entity);
	void handle_wall_player_collision(Entity projectile_entity, Entity enemy_entity);
	void handle_player_enemy_collision(Entity player_entity, Entity enemy_entity);
	void handle_player_enemy_room_collision(Entity player_entity, Entity enemy_room_entity);
	void handle_projectile_environment_object_collision(Entity projectile_entity, Entity environment_object_entity);
	void on_interact_pressed(int key, int mods);

	void notify_room_manager();
	void removeWallsFromRoom(Entity room_manager_entity);
	void addWallsToRoom(Entity room_manager_entity);


	void update_tutorial_stage();

	void startPlayerDeathSequence();

	void display_setting_info();

	// Munn: We can put game related variables here (eg. gold) 
	//int next_invader_spawn;
	//int invader_spawn_rate_ms;	// see default value in common.hpp

	//int max_towers;	// see default value in common.hpp

	//// Number of invaders stopped by the towers, displayed in the window title
	//unsigned int points;

	// Game state
	RenderSystem* renderer;
	float current_speed;
	GAME_SCREEN_ID game_screen;

	void goto_next_cutscene();

	// Tutorial
	int tutorial_stage = 0;
	bool stage_presented = false;
	//bool enemy_killed = false;

	// grid
	std::vector<Entity> grid_lines;

	// music references
	Mix_Music* background_music;
	Mix_Chunk* pipe;
	Mix_Chunk* player_hurt;
	Mix_Chunk* enemy_spawned;
	Mix_Chunk* enemy_hurt;


	// Munn: some private helpers for movement and key presses
	void handle_dashing_movement(Motion& playerMotion, float stepSeconds);
	void handle_walking_movement(Motion& playerMotion, vec2 move_direction, float stepSeconds);
	void handle_key_held_update(RenderSystem* renderer, vec2 move_direction);
	void update_player_animations(Entity player_entity); 
	void update_player_particles(Entity player_entity, Motion& playerMotion);


	void update_window_caption();

	int highest_score = 0;
	std::vector<int> top_10_score;
	void update_record();

	int current_kills = 0;
	int current_floor;
	bool is_in_combat = false;

	std::vector<int> keys;
	std::string record_element = "";

	int getFPS();
};

extern float mouse_pos_x;
extern float mouse_pos_y;
